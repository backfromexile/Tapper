<#@ template language="C#" linePragmas="false" debug="false" hostspecific="false"#>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
    string[] CollectionTypes = new[]
    {
        "Array",
        "ArraySegment<int>",
        "List<float>",
        "LinkedList<string>",
        "Queue<Guid>",
        "Stack<Uri>",
        "HashSet<DateTime>",
        "IEnumerable<bool>",
        "IReadOnlyCollection<byte>",
        "IReadOnlyList<object>",
        "ICollection<string>",
        "IList<bool>",
        "ISet<sbyte>",
    };

    static string Format(string source)
    {
        return source.Replace("<", null) .Replace(">", null).Replace(",", null);
    }
#>
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY Tapper.Test.SourceTypes
// </auto-generated>
#nullable enable
using System;
using System.Collections.Generic;

namespace Tapper.Tests.SourceTypes;

#pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.

<# foreach(var type in CollectionTypes){ #>
[TranspilationSource]
public class ClassIncludeCollectionField<#= Format(type) #>
{
    public <#= type #> FieldOf<#= Format(type) #>;
}

<# } #>
<# foreach(var type in CollectionTypes){ #>
[TranspilationSource]
public class ClassIncludeCollectionProperty<#= Format(type) #>
{
    public <#= type #> PropertyOf<#= Format(type) #> { get; set; }
}

<# } #>
#pragma warning restore CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
