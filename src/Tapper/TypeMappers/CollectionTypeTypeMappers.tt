<#@ template language="C#" linePragmas="false" debug="false" hostspecific="false"#>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
    Type[] collectionTypes = new[]
    {
        typeof(ArraySegment<>),
        typeof(List<>),
        typeof(LinkedList<>),
        typeof(Queue<>),
        typeof(Stack<>),
        typeof(HashSet<>),
        typeof(IEnumerable<>),
        typeof(IReadOnlyCollection<>),
        typeof(IReadOnlyList<>),
        typeof(ICollection<>),
        typeof(IList<>),
        typeof(ISet<>),
    };
#>
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY Tapper
// </auto-generated>
#nullable enable
using System;
using Microsoft.CodeAnalysis;

namespace Tapper.TypeMappers;

public class SystemArrayTypeMapper : ITypeMapper
{
    public ITypeSymbol Assign { get; }

    public SystemArrayTypeMapper(Compilation compilation)
    {
        Assign = compilation.GetTypeByMetadataName("System.Array")!;
    }

    public string MapTo(ITypeSymbol typeSymbol, ITranspilationOptions options)
    {
        if (SymbolEqualityComparer.Default.Equals(typeSymbol, Assign))
        {
            return "any[]";
        }

        throw new InvalidOperationException($"SystemArrayTypeMapper is not support {typeSymbol.ToDisplayString()}.");
    }
}

<# foreach(var type in collectionTypes){ #>
public class <#= type.Name.Replace("`", null) #>TypeMapper : ITypeMapper
{
    public ITypeSymbol Assign { get; }

    public <#= type.Name.Replace("`", null) #>TypeMapper(Compilation compilation)
    {
        Assign = compilation.GetTypeByMetadataName("<#= type.FullName #>")!;
    }

    public string MapTo(ITypeSymbol typeSymbol, ITranspilationOptions options)
    {
        if (typeSymbol is INamedTypeSymbol namedTypeSymbol
            && namedTypeSymbol.IsGenericType
            && SymbolEqualityComparer.Default.Equals(namedTypeSymbol.ConstructedFrom, Assign))
        {
            var typeArgument = namedTypeSymbol.TypeArguments[0];
            var mapper = options.TypeMapperProvider.GetTypeMapper(typeArgument);
            return $"{mapper.MapTo(typeArgument, options)}[]";
        }

        throw new InvalidOperationException($"<#= type.Name.Replace("`", null) #>TypeMapper is not support {typeSymbol.ToDisplayString()}.");
    }
}

<# } #>
public static class CollectionTypeTypeMappers
{
    public static ITypeMapper[] Create(Compilation compilation)
    {
        var mappers = new ITypeMapper[<#= collectionTypes.Length + 1 #>];

        mappers[0] = new SystemArrayTypeMapper(compilation);
<# foreach(var (type, index) in collectionTypes.Select((x, index) => (x, index))){ #>
        mappers[<#= index + 1 #>] = new <#= type.Name.Replace("`", null) #>TypeMapper(compilation);
<# } #>

        return mappers;
    }
}
